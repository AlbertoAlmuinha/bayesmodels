% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parsnip_sarima_reg.R
\name{sarima_reg}
\alias{sarima_reg}
\title{General Interface for ARIMA Regression Models}
\usage{
sarima_reg(
  mode = "regression",
  seasonal_period = NULL,
  non_seasonal_ar = NULL,
  non_seasonal_differences = NULL,
  non_seasonal_ma = NULL,
  seasonal_ar = NULL,
  seasonal_differences = NULL,
  seasonal_ma = NULL,
  markov_chains = NULL,
  chain_iter = NULL,
  warmup_iter = NULL,
  adapt_delta = NULL,
  tree_depth = NULL,
  pred_seed = NULL
)
}
\arguments{
\item{mode}{A single character string for the type of model.
The only possible value for this model is "regression".}

\item{seasonal_period}{A seasonal frequency. Uses "auto" by default.
A character phrase of "auto" or time-based phrase of "2 weeks"
can be used if a date or date-time variable is provided.
See Fit Details below.}

\item{non_seasonal_ar}{The order of the non-seasonal auto-regressive (AR) terms. Often denoted "p" in pdq-notation.}

\item{non_seasonal_differences}{The order of integration for non-seasonal differencing. Often denoted "d" in pdq-notation.}

\item{non_seasonal_ma}{The order of the non-seasonal moving average (MA) terms. Often denoted "q" in pdq-notation.}

\item{seasonal_ar}{The order of the seasonal auto-regressive (SAR) terms. Often denoted "P" in PDQ-notation.}

\item{seasonal_differences}{The order of integration for seasonal differencing. Often denoted "D" in PDQ-notation.}

\item{seasonal_ma}{The order of the seasonal moving average (SMA) terms. Often denoted "Q" in PDQ-notation.}

\item{markov_chains}{An integer of the number of Markov Chains chains to be run, by default 4 chains are run.}

\item{chain_iter}{An integer of total iterations per chain including the warm-up, by default the number of iterations are 2000.}

\item{warmup_iter}{A positive integer specifying number of warm-up (aka burn-in) iterations. This also specifies the number of iterations used for step-size adaptation, so warm-up samples should not be used for inference. The number of warmup should not be larger than iter and the default is iter/2.}

\item{adapt_delta}{An optional real value between 0 and 1, the thin of the jumps in a HMC method. By default is 0.9}

\item{tree_depth}{An integer of the maximum depth of the trees evaluated during each iteration. By default is 10.}

\item{pred_seed}{An integer with the seed for using when predicting with the model.}
}
\value{
A model spec
}
\description{
\code{sarima_reg()} is a way to generate a \emph{specification} of an ARIMA model
before fitting and allows the model to be created using
different packages. Currently the only package is \code{bayesforecast}.
}
\details{
The data given to the function are not saved and are only used
to determine the \emph{mode} of the model. For \code{sarima_reg()}, the
mode will always be "regression".

The model can be created using the \code{fit()} function using the
following \emph{engines}:
\itemize{
\item "stan" (default) - Connects to \code{\link[bayesforecast:stan_sarima]{bayesforecast::stan_sarima()}}
}

\strong{Main Arguments}

The main arguments (tuning parameters) for the model are:
\itemize{
\item \code{non_seasonal_ar}: The order of the non-seasonal auto-regressive (AR) terms.
\item \code{non_seasonal_differences}: The order of integration for non-seasonal differencing.
\item \code{non_seasonal_ma}: The order of the non-seasonal moving average (MA) terms.
\item \code{seasonal_ar}: The order of the seasonal auto-regressive (SAR) terms.
\item \code{seasonal_differences}: The order of integration for seasonal differencing.
\item \code{seasonal_ma}: The order of the seasonal moving average (SMA) terms.
\item \code{markov_chains}: An integer of the number of Markov Chains chains to be run.
\item \code{adapt_delta}: The thin of the jumps in a HMC method.
\item \code{tree_depth}: The maximum depth of the trees evaluated during each iteration
}

These arguments are converted to their specific names at the
time that the model is fit.

Other options and argument can be
set using \code{set_engine()} (See Engine Details below).

If parameters need to be modified, \code{update()} can be used
in lieu of recreating the object from scratch.
}
\section{Engine Details}{


The standardized parameter names in \code{bayesmodels} can be mapped to their original
names in the engine:\tabular{ll}{
   bayesmodels \tab bayesforecast::stan_sarima \cr
   non_seasonal_ar, non_seasonal_differences, non_seasonal_ma \tab order = c(p(1), d(0), q(0)) \cr
   seasonal_ar, seasonal_differences, seasonal_ma \tab seasonal = c(P(0), D(0), Q(0)) \cr
   markov_chains \tab chains(4) \cr
   adapt_delta \tab adapt.delta(0.9) \cr
   tree_depth \tab tree.depth(10) \cr
}


Other options can be set using \code{set_engine()}.

\strong{stan (default engine)}

The engine uses \code{\link[bayesforecast:stan_sarima]{bayesforecast::stan_sarima()}}.

Parameter Notes:
\itemize{
\item \code{xreg} - This is supplied via the parsnip / bayesmodels \code{fit()} interface
(so don't provide this manually). See Fit Details (below).
}
}

\section{Fit Details}{


\strong{Date and Date-Time Variable}

It's a requirement to have a date or date-time variable as a predictor.
The \code{fit()} interface accepts date and date-time features and handles them internally.
\itemize{
\item \code{fit(y ~ date)}
}

\emph{Seasonal Period Specification}

The period can be non-seasonal (\verb{seasonal_period = 1 or "none"}) or
yearly seasonal (e.g. For monthly time stamps, \code{seasonal_period = 12}, \code{seasonal_period = "12 months"}, or \code{seasonal_period = "yearly"}).
There are 3 ways to specify:
\enumerate{
\item \code{seasonal_period = "auto"}: A seasonal period is selected based on the periodicity of the data (e.g. 12 if monthly)
\item \code{seasonal_period = 12}: A numeric frequency. For example, 12 is common for monthly data
\item \code{seasonal_period = "1 year"}: A time-based phrase. For example, "1 year" would convert to 12 for monthly data.
}

\strong{Univariate (No xregs, Exogenous Regressors):}

For univariate analysis, you must include a date or date-time feature. Simply use:
\itemize{
\item Formula Interface: \code{fit(y ~ date)} will ignore xreg's.
}

\strong{Multivariate (xregs, Exogenous Regressors)}

The \code{xreg} parameter is populated using the \code{fit()} function:
\itemize{
\item Only \code{factor}, \verb{ordered factor}, and \code{numeric} data will be used as xregs.
\item Date and Date-time variables are not used as xregs
\item \code{character} data should be converted to factor.
}

\emph{Xreg Example:} Suppose you have 3 features:
\enumerate{
\item \code{y} (target)
\item \code{date} (time stamp),
\item \code{month.lbl} (labeled month as a ordered factor).
}

The \code{month.lbl} is an exogenous regressor that can be passed to the \code{sarima_reg()} using
\code{fit()}:
\itemize{
\item \code{fit(y ~ date + month.lbl)} will pass \code{month.lbl} on as an exogenous regressor.
}

Note that date or date-time class values are excluded from \code{xreg}.
}

\examples{
\dontrun{
library(dplyr)
library(parsnip)
library(rsample)
library(timetk)
library(modeltime)
library(bayesmodels)

# Data
m750 <- m4_monthly \%>\% filter(id == "M750")
m750

# Split Data 80/20
splits <- rsample::initial_time_split(m750, prop = 0.8)

# ---- ARIMA ----

# Model Spec
model_spec <- sarima_reg() \%>\%
    set_engine("stan")

# Fit Spec
model_fit <- model_spec \%>\%
    fit(log(value) ~ date, data = training(splits))
model_fit



# Model Spec
model_spec <- sarima_reg(
        seasonal_period          = 12,
        non_seasonal_ar          = 3,
        non_seasonal_differences = 1,
        non_seasonal_ma          = 3,
        seasonal_ar              = 1,
        seasonal_differences     = 0,
        seasonal_ma              = 1
    ) \%>\%
    set_engine("stan")

# Fit Spec
model_fit <- model_spec \%>\%
    fit(log(value) ~ date, data = training(splits))
model_fit
}
}
\seealso{
\code{\link[=fit.model_spec]{fit.model_spec()}}, \code{\link[=set_engine]{set_engine()}}
}
